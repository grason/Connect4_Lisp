(defun make-board (rows columns)
;; this is pretty non-functional :)
(loop for x from 1 to rows
      collect (loop for y from 1 to columns
		    collect nil) ))
(defun print-items (items)
(mapcar (lambda (item) (if (null item)(format t "| - ") (format t "| ~A " item))) items)
(format t "|~%"))

(defun print-matrix (board)
  (dotimes (i (length board))
    (print-items (nth i board))))

;this has to be a scoping error i swear. I rewrote the entire thing, and there isn't a way this shouldn't be working unless its not passing the variables correctly between the parts. If you know how to make variables global, then we could fix this quickly

(defun winHor (board win)
  (let ((allwin nil))
    (dotimes (row (length board) allwin)
        (dotimes (col ( - (length (first board)) (- win 1)) allwin)
          (let ((start col))
                (if (< (+ start win) (- (length (first board)) 1))
                    (let ((winner (nth col (nth row board))))
                        (dotimes (winCol win winner)
                            (if (eq (nth (+ winCol start) (nth row board)) winner)
                                (setf winner (nth (+ winCol start) (nth row board)))
                                (setf winner nil)
                            )
                        )
                    (if (not (null winner))
                        (setf allwin winner)))))))))

(defun winCol (board win)
    (let ((allwin nil))
        (dotimes (col (length (first board)) allwin)
            (dotimes (row ( - (length board) (- win 1)) allwin)
                (let ((start row))
                    (if (< (+ start win) (- (length board) 1))
                        (let ((winner (nth col (nth row board))))
                            (dotimes (winRow win winner)
                                (if (eq (nth col (nth (+ winRow start) board)) winner)
                                    (setf winner (nth col (nth (+ winRow start) board)))
                                    (setf winner nil)
                                )
                            )
                        (if (not (null winner))
                            (setf allwin winner)))))))))

(defun winDiaFor (board win)
    (let ((allwin nil))
        (dotimes (row (- (length board) (- win 1)) allwin)
            (dotimes (col (- (length (first board)) (- win 1)) allwin)
                (let ((startr row))
                    (let ((startc col))
                        (if (and (< (+ startr win) (- (length board) 1))
                                (< (+ startc win) (- (length (first board)) 1)))
                            (let ((winner (nth col (nth row board))))
                                (dotimes (winMove win winner)
                                    (if (eq (nth ( + winMove startc) (nth (+ winMove startr) board)) winner)
                                        (setf winner (nth (+ winMove startc) (nth (+ winMove startr) board)))
                                        (setf winner nil)
                                    )
                                )
                            (if (not (null winner))
                                (setf allwin winner))))))))))

(defun winDiaBack (board win)
    (let ((allwin nil))
        (dotimes (row (- (length board) (- win 1)) allwin)
            (dotimes (Col (- (length (first board)) (- win 1)) allwin)
                (let ((startr row))
                    (let ((startc col))
                        (if (and (< (+ startr win) (- (length board)) 1))
                                 (> (- startc win) 0)
                            (let ((winner (nth col (nth row board))))
                                (dotimes (winMove win winner)
                                    (if (eq (nth (- startc winMove) (nth (+ startr winMove) board)) winner)
                                        (setf winner (nth (- startc winMove) (nth (+ startr winMove) board)))
                                        (setf winner nil)
                                    )
                                )
                            (if (not (null winner))
                                (setf allwin winner))))))))))
							
(defun who-won (win board)
	(let ((winner nil))
	(if (winDiaBack board win)
		(setf winner (winDiaBack board win)))
	(if	(winDiaFor board win)
		(setf winner (winDiaFor board win)))
	(if	(winHor board win)
		(setf winner (winHor board win)))
	(if (winCol board win)
		(setf winner (winCol board win)))))
		
(defun place-token (player col board)
  (if (not(null (nth col (first (last board)))))
	  (place-token player col (butlast board) ) (setf (nth col (first (last board))) player)))
